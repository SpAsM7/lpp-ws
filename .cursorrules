# Absolute Code Rules

## 1. Tech Stack & Overview

This project is a Next.js-based LP Portal that provides limited partners with a secure interface for viewing and managing investment data, documents, and updates. Our data source is **Airtable** (where GPs store and manage records), and user authentication is handled by **Supabase**.

1. **Frontend**  
   - Next.js 15 with App Router  
   - React 18 with Server Components  
   - TypeScript with strict mode  
   - Tailwind CSS  
   - shadcn UI components (Zinc theme)

2. **Database & Platform**  
   - **Airtable** for all LP-related data (documents, roles, accounts, etc.)  
   - **Supabase** for user authentication only:
     - Sign-up, sign-in, password resets, and JWT issuance
     - We do **not** use Supabase Postgres for data storage or row-level security

3. **Infrastructure**  
   - Vercel for Frontend & Serverless Functions  
   - Airtable as primary DB (via its API/SDK)  
   - Supabase Cloud for Authentication  
   - MUST use `.env` for local development  
   - MUST use `.env.example` for documenting variables  
   - MUST prefix client-side variables with `NEXT_PUBLIC_`  
   - MUST NEVER commit `.env` to version control

4. **Additional Libraries**  
   - React Hook Form & Zod for form handling  
   - TanStack Query for data fetching  
   - TanStack Table for data tables  
   - Recharts for data visualization  
   - date-fns for date handling  

---

## 2. Environment Variables

1. **File Usage**  
   - MUST use `.env.local` for local development  
   - MUST use `.env.example` for documenting **all** variables  
   - MUST NEVER commit `.env.local` or other `.env.*` files  
   - MUST keep `.env.example` up to date with every required variable  

2. **Variable Naming**  
   - MUST prefix client-side variables with `NEXT_PUBLIC_`  
   - MUST use SCREAMING_SNAKE_CASE for all variables  
   - MUST prefix feature flags with `FEATURE_` (e.g. `FEATURE_SOMETHING_EXPERIMENTAL`)  

3. **Security**  
   - MUST store credentials such as the **Airtable API key** and **Supabase keys** in environment variables  
   - MUST NEVER expose sensitive values in client-side code  
   - MUST NEVER log environment variables  
   - MUST validate all required environment variables on startup  

---

## 3. Rule Conventions

This document uses specific keywords to indicate requirement levels:

- **MUST / MUST NOT**: Absolute requirements that cannot be ignored  
- **SHOULD / SHOULD NOT**: Strong recommendations that can be deviated from only if fully understood  
- **MAY**: Optional items  

---

## 4. Development Workflow

### 4.1 Airtable & Supabase Management

1. **Schema Changes**:
   - MUST be performed manually by user in Airtable UI
   - MUST NOT attempt direct schema modifications via code
   - MUST wait for user confirmation before implementing dependent code
   - MUST prompt user with specific changes needed:
     - For Airtable: exact field names, types, and configurations
     - For Supabase: complete SQL statements for schema changes
   - MUST include examples in change requests (e.g., "Please add `Document_Type` field as Single Select to Documents table with options: ['K1', 'Statement', 'Report']")

2. **Auth Configuration**:
   - MUST be configured manually by user in Supabase dashboard
   - MUST NOT modify auth settings programmatically
   - MUST document required auth provider changes

### 4.2 Documentation Requirements

1. **Reference Files**:
   - MUST maintain `/PRD/product-requirements.md` for feature scope, update when new features are added
   - MUST maintain `/PRD/component-requirements.md` for implementation details, update when components are changed and track when existing components are completed
   - MUST maintain `/PRD/app-flow.mermaid` for flow documentation, update when flows are added or changed
   - MUST maintain `/PRD/working-status.md` for progress tracking, update at each logical step of the project

2. **Documentation Updates**:
   - MUST update docs when implementing new features
   - MUST update docs when modifying existing features
   - MUST NOT introduce conflicting requirements

### 4.3 Implementation Process

1. **Schema Coordination**:
   - MUST request Airtable changes before dependent code
   - MUST specify exact field names and types
   - MUST wait for confirmation before proceeding

2. **Feature Implementation**:
   - MUST check component requirements before coding
   - MUST update working status during development
   - MUST ensure docs reflect actual implementation
   - MUST raise conflicts for user decision

---

## 5. Project Structure Overview

```
/
├── app/                    # Next.js App Router (pages and API routes)
│   ├── (auth)/            # Auth pages and their specific components
│   │   └── _components/   # Components used ONLY by auth pages
│   ├── (dashboard)/       # Main pages and their specific components
│   │   └── _components/   # Components used ONLY by dashboard pages
│   └── api/               # API routes (auth endpoints, webhooks, etc.)
├── src/
│   ├── lib/               # Shared code and business logic
│   │   ├── domains/       # Core business domains (accounts, companies, investments)
│   │   ├── features/      # Cross-domain features (document-access, metrics)
│   │   ├── actions/       # Server Actions organized by feature or domain
│   │   ├── errors/        # Centralized error dictionary
│   │   ├── airtable/      # Airtable queries and utilities
│   │   └── supabase/      # Supabase client configs (client.ts, server.ts) for auth
│   ├── components/        # Shared components used across multiple pages
│   │   ├── ui/            # shadcn components (buttons, inputs, etc.)
│   │   ├── layout/        # Layout wrappers (headers, sidebars)
│   │   ├── loading/       # Loading states and skeletons
│   │   ├── forms/         # Shared form components
│   │   ├── icons/         # Centralized icon components
│   │   ├── providers/     # Context providers
│   │   ├── [domain]/      # Components shared within a domain (e.g., accounts/)
│   │   └── [feature]/     # Components shared within a feature
│   └── types/             # Shared TypeScript types
├── tests/                 # Tests (unit in __tests__, e2e in e2e/)
├── public/                # Static assets
├── .env.example           # Environment variable documentation
└── middleware.ts          # Edge middleware for authentication
```

1. All shared code MUST go in `/src/lib`  
2. All shared types MUST go in `/src/types`  
3. All environment variables MUST be defined in `.env.example`  
4. MUST use absolute imports from `@/` not relative paths  
5. MUST NOT put business logic in components  
6. **Business Logic Organization**  
   - Core domains MUST be placed in `/src/lib/domains/[domain]`  
     - e.g. accounts, companies, investments, documents  
   - Features that cross multiple domains MUST be placed in `/src/lib/features/[feature]`  
7. **File Size Management**  
   - Each file SHOULD be under 300 lines of code  
   - SHOULD split large modules into smaller logical pieces  
8. **File Documentation**  
   - Each file MUST begin with a short comment summarizing its purpose  
   - MUST list key exports (e.g. `// Exports: MyComponent, useMyHook, MyType`)  
   - MUST reference these rules (e.g. `// See: docs/coding-rules.md`)  
   - MUST keep descriptions concise and focused  

---

## 6. Route Structure

1. **API routes** MUST go in `/app/api/**/route.ts`  
2. **API routes** MUST NOT be affected by route groups  
3. **Pages** MUST go in folder matching their URL path:  
   - URL `/auth/login` → `/app/auth/login/page.tsx`  
   - URL `/dashboard` → `/app/dashboard/page.tsx`  
4. **Route groups** MUST ONLY be used for organizing pages (e.g., `(auth)` group)  
5. **Route groups** MUST NOT contain API routes  
6. All request-specific APIs (`cookies`, `headers`, `params`, `searchParams`) MUST be async  
7. **Next.js Layouts**  
   - Route-level `layout.tsx` MUST be used for shared UI within route groups  
   - Route-level `layout.tsx` MUST NOT contain complex component logic  
8. MUST use App Router in `/app` - MUST NOT use the legacy Pages Router  
9. Route groups SHOULD NOT be nested more than two levels deep  

---

## 7. Loading States

1. MUST wrap client components in Suspense boundaries  
2. MUST NOT show raw loading spinners - MUST use shadcn skeleton components  
3. MUST use route-specific `loading.tsx` for page-level loading states  
4. SHOULD co-locate component-specific loading states with their components  
5. MUST place reusable loading components in `/src/components/loading`  

---

## 8. Authentication

We rely on **Supabase** exclusively for user sign-up, log-in, and password resets. **All** user-facing data is stored in Airtable; user data remains in Supabase only for auth (email, password, session tokens).

1. **Auth Endpoints** MUST follow these patterns (under `/app/api/auth/`):  
   - `login/route.ts` - Sign in handlers (email, OAuth)  
   - `signup/route.ts` - Sign up handlers  
   - `signout/route.ts` - Sign out handler  
   - `callback/route.ts` - OAuth/magic link callbacks  
   - `reset-password/route.ts` - Password reset  
   - `update-password/route.ts` - Password update after reset  
   - `verify/route.ts` - Email verification  

   **Page Components** (under `/app/auth/`):  
   - `login/page.tsx` - Sign in forms (URL: `/auth/login`)  
   - `signup/page.tsx` - Sign up forms (URL: `/auth/signup`)  
   - `callback/page.tsx` - Auth callback handling (URL: `/auth/callback`)  
   - `reset-password/page.tsx` - Password reset forms (URL: `/auth/reset-password`)  
   - `update-password/page.tsx` - Password update forms (URL: `/auth/update-password`)  
   - `verify/page.tsx` - Email verification (URL: `/auth/verify`)

2. **Supabase Client Methods**  
   - **Client Components**: Use `createClient()` from `@/lib/supabase/client`  
   - **Server Components**: Use `createClient()` from `@/lib/supabase/server`  
   - **Middleware**: Use `createServerClient()` from `@supabase/ssr`  
   - **Route Handlers**: Use `createClient()` from `@/lib/supabase/server`  

3. Never manipulate cookies directly – use Supabase session methods  
4. Always handle auth state changes through proper session management  
5. Protected routes MUST be handled in `middleware.ts`  
6. Never store auth tokens or user data in localStorage/client state  

---

## 9. Data Management (Airtable)

All investment, document, role, and account data is kept in **Airtable**, while Supabase handles authentication only.

1. **Architecture**:
   - MUST keep all Airtable operations in `/src/lib/airtable`
   - MUST store credentials (base IDs, API keys) in environment variables
   - MUST use TypeScript interfaces for all Airtable tables
   - MUST NEVER use `any` types for Airtable records

2. **File Organization**:
   - `/src/lib/airtable/client.ts` - API configuration
   - `/src/lib/airtable/queries.ts` - Reusable queries
   - `/src/types/airtable.ts` - Type definitions

3. **Data Access Patterns**:
   - **Server Components**: Use Airtable SDK directly
   - **Client Components**: Use Server Actions for Airtable operations
   - **API Routes**: Use SDK only for external integrations/webhooks
   - MUST NOT fetch same data in child components if parent has it
   - MUST pass fetched data down via props
   - MUST filter data by user's `supabase_uuid` before returning results

4. **Performance & Scaling**:
   - MUST implement pagination/filtering for large datasets
   - MUST batch related changes when possible
   - MUST use formula fields for computed values
   - SHOULD cache frequently accessed data
   - MUST monitor API usage limits
   - MUST use meaningful loading states

5. **Data Conventions**:
   - **Currency Storage**:
     - Store currency as whole numbers in dollars (never cents)
     - Use Airtable's integer field type for currency
     - NEVER use floating-point or text-based currency fields
     - Display large values in K/M format (e.g., $10M, $500K)
   - **IDs and References**:
     - Use UUID for IDs (stored as strings in Airtable)
     - Include audit fields (created_at, updated_at as Date/Time type)
     - Use Linked Record fields for relationships between tables
   - **Field Types & Validation**:
     - MUST use appropriate Airtable field types:
       - Single Select for enumerated values
       - Multiple Select for flag/tag combinations
       - Number (integer) for whole numbers
       - Number (decimal, 2 places) for percentages
       - Long Text for markdown/formatted content
       - Attachment for files/documents
     - MUST handle Airtable type constraints:
       - Number fields may return null/undefined
       - Formula fields are read-only and may have precision limits
       - Date fields need explicit timezone handling
     - MUST validate all data with Zod:
       - Parse number fields with appropriate checks
       - Validate select fields against known values
       - Handle null/undefined gracefully
     - MUST NEVER store sensitive data in unstructured fields
     - MUST document field type choices in schema documentation

6. **Permissions Model**:
   - Link records to User_Profiles table for permissions
   - Verify `supabase_uuid` membership in allowed users
   - Implement row-level filtering in serverless code
   - Document all permission logic in comments
   - NEVER mix GP and LP role checks
   - Use explicit function names for context (e.g., `getGPUsers`)

## 10. Schema Management

1. **Documentation**:
   - MUST maintain changelog in `/docs/airtable-schema/`
   - MUST document all tables and relationships
   - MUST version changes with timestamps
   - MUST include rollback procedures

2. **Change Process**:
   - MUST test in development base first
   - MUST document impact on existing data
   - MUST update TypeScript types
   - MUST validate permission logic
   - MUST backup data before significant changes
   - MUST maintain referential integrity

3. **Communication**:
   - MUST notify team of changes
   - MUST document breaking changes
   - MUST coordinate with GP administrators
   - MUST provide migration guides when needed

---

## 11. Middleware

1. MUST exist in `middleware.ts` at project root  
2. Use `createServerClient()` from `@supabase/ssr` to handle authentication in middleware  
3. Must ensure a user is authenticated (if route requires login) before allowing access  
4. DO NOT add application logic in page or API route files for restricting access—enforce in middleware + serverless checks  

---

## 12. Components

1. **Architecture**:
   - MUST default to Server Components
   - MUST add `'use client'` when component needs:
     - Interactivity (`onClick`, `onChange`)
     - Browser APIs
     - React hooks (`useState`, `useEffect`)
     - Forms (react-hook-form requirement)
   - MUST add `'use server'` at Server Action file top
   - MUST add `'use server'` for inline Server Actions

2. **Component Types**:
   - **Server Components**:
     - MUST handle all data fetching
     - MUST contain primary business logic
     - MUST pass only necessary props to clients
   - **Client Components**:
     - MUST be leaf nodes when possible
     - MUST NOT contain business logic
     - MUST focus solely on UI interactivity
     - SHOULD be small and focused
   - NEVER convert to Client Component just for:
     - Data fetching
     - Rendering optimization
     - Code organization

3. **UI Components**:
   - MUST use shadcn UI components over raw HTML/Tailwind
   - MUST install via `pnpm dlx shadcn@latest add <component-name>`
   - MUST NOT copy/paste shadcn code directly
   - MUST NOT modify shadcn source files (extend through composition)

4. **Organization**:
   - **Cross-Cutting UI**: `src/components/ui/` for basic building blocks (Button, Input, etc.)
   - **Layout**: `src/components/layout/` for shared navigation, sidebars, headers
   - **Loading**: `src/components/loading/` for skeleton or spinner components
   - **Providers**: `src/components/providers/` for context providers
   - **[domain]/[feature]**: for domain/feature-specific components used by multiple pages
   - Page-specific components: in `app/**/[page]/_components/`

5. **Naming**:
   - MUST use kebab-case for file and directory names (`user-profile.tsx`, `investment-table.tsx`)
   - MUST use PascalCase for React component names (`export function UserProfile()`)

6. **Business Logic**:
   - MUST NOT include complex domain logic
   - MUST pass data through props from server components
   - MUST use Server Actions for mutations

---

## 13. Server-Side Logic

1. **Data Mutations**:
   - MUST use Server Actions for all Airtable operations
   - MUST use API Routes ONLY for:
     - External integrations
     - Webhooks
     - Streaming data
   - MUST NOT create API Routes for internal operations

2. **Server Action Organization**:
   - MUST follow CRUD order: Create, Read, Update, Delete
   - MUST use consistent naming:
     - Files: `[feature]-actions.ts` or `[domain]-actions.ts`
     - Functions: `[action][Feature]Action` or `[action][Domain]Action` (e.g., `createDocumentAction`, `updateRoleAction`)
   - MUST organize by domain/feature:
     - Core domain actions in `/src/lib/actions/[domain]`
     - Cross-domain features in `/src/lib/actions/[feature]`
   - MUST export as named functions
   - MUST use consistent naming: `handle[Action]Action`
   - MUST place shared logic in domain services
   - MAY reuse service functions across actions

3. **Return Types**:
   - MUST use `ActionState<T>` pattern:
     ```ts
     type ActionState<T> = {
       isSuccess: boolean;
       message: string;
       data?: T;
       fieldErrors?: Record<string, string[]>;
     };
     ```
   - MUST return `Promise<ActionState<T>>`
   - MUST handle all error states
   - MUST log detailed errors server-side
   - MUST return user-friendly messages

---

## 14. Error Handling

1. **Error Boundaries**:
   - MUST use error boundaries at the page level
   - MUST provide fallback UI for each boundary
   - MUST log boundary catches server-side

2. **Error Messages**:
   - MUST come from `/src/lib/errors` dictionary
   - MUST include user-friendly message and next steps
   - MUST support i18n through message keys
   - NEVER show raw error messages (Airtable or Supabase error text) to users
   - NEVER hardcode messages in components
   - MUST translate known error codes into user-friendly text

3. **Error Handling Patterns**:
   - MUST catch errors at function start with early returns
   - MUST model expected errors as return values
   - MUST log detailed errors server-side
   - NEVER catch errors without handling them
   - MUST provide recovery paths where possible
   - MUST handle all possible error states with appropriate messages

---

## 15. Dependencies/Packages

1. **Airtable**  
   - Use the official Airtable API or Node SDK in `/src/lib/airtable`  
   - Keep version pinned (no `^` or `~` in package.json)  
   - NEVER commit tokens or keys  

2. **Supabase**  
   - Only for auth; pinned version; do not import unused subpackages (e.g., Postgres clients or storage)  

3. **UI Libraries**  
   - MUST stick to shadcn (Radix under the hood)  
   - MUST NOT add other competing UI libraries  

4. **General**  
   - Keep dependencies updated to patch versions for security  
   - MUST remove any unused dependencies  

---

## 16. Code Style

1. **Directory Names**: use lowercase with dashes (e.g. `user-management`)  
2. **Exports**: prefer named exports over default exports  
3. **Order** in files: top-level exports → subcomponents → helpers → static content → types  
4. **Conditionals**: omit curly braces for single-line if statements  
5. **Variable Names**: must be descriptive, especially booleans (`isLoading`, `hasError`)  

---

## 17. Styling & Theme

1. **shadcn Theme**  
   - Must use theme tokens (e.g. `text-primary`, `bg-accent`)  
   - No hardcoded color strings that conflict with the theme  

2. **Component Variants**  
   - Use `cva` from class-variance-authority for styling variants  
   - Keep variant definitions in the component’s file  

3. **CSS Variables**  
   - Use `hsl(var(--primary))` for color references  
   - Avoid raw hex/hsl in code  

4. **Dark Mode**  
   - Always handle `dark:` classes; test all components in light and dark modes  

5. **Style Inheritance**  
   - Use `className` for overrides  
   - Implement `forwardRef` when needed  
   - Do not inline style large blocks unless absolutely necessary  

---

## 18. Code Editing & Content Preservation

1. NEVER use placeholders like `[Previous content is the same]` or `[Existing Content]` when editing code. Always show the entire updated file or section.  
2. Use proper version control. Changes must be explicit.  
3. All code changes must be visible in a diff.  
4. MUST NOT make UI changes during edits unless:
   - The user has explicitly requested UI changes, or
   - You have requested and received explicit permission from the user to change the UI
   - This applies to all visual changes including layout, styling, component structure, and interaction patterns
---

## 19. Testing

1. **Test Location**  
   - Co-locate feature tests with the code in `__tests__` subdirectories  
   - End-to-end tests go in `/tests/e2e`  

2. **Test Files**  
   - Use `.test.ts` for unit tests, `.spec.ts` for integration tests  
   - Match the source file name (e.g., `Button.tsx` → `Button.test.tsx`)  

3. **Test Tools**  
   - Use Vitest for unit tests  
   - Use Playwright for integration/e2e tests  

4. **Coverage**  
   - Ensure coverage for all critical data-handling code (Airtable row checks, role logic)  
   - Include GP/LP role separation logic in tests  